<!DOCTYPE html>

<meta charset="UTF-8" />
<title>WebCodecs API demo: Encoding and Decoding</title>
<style>
  button {
    background-color: #555555;
    border: 2px;
    border-radius: 2px;
    color: white;
    padding: 15px 32px;
    width: 1280px;
    text-align: center;
    display: block;
    font-size: 16px;
  }
</style>

<button id="record" width="1280" onclick="onButtonClicked()">Record</button>
<video id="video_camera" autoplay muted width="1280" height="720"></video>
<script>
  let video = document.getElementById("video_camera");
  let button = document.getElementById("record");
  let encodeWorker = null;
  let stream = null;
  let videoTrack = null;

  async function startRecording() {
    console.assert(button.innerText == "Record");
    // diable buttong to stop multiple recordings
    button.disabled = true;

    // choose where to save the file
    handle = await window.showSaveFilePicker({
      startIn: "videos",
      suggestedName: "ryan_kiana.mp4",
      types: [
        {
          description: "Video File",
          accept: { "video/mp4": [".mp4"] },
        },
      ],
    });

    // gets the first video track from media stream
    videoTrack = stream.getTracks()[0];
    let trackSettings = videoTrack.getSettings();
    // allows it to read individual frames from the video stream
    let trackProcessor = new MediaStreamTrackProcessor(videoTrack);
    let frameStream = trackProcessor.readable;

    // Encoder I/O and file writing happens in a Worker to keep the UI
    // responsive.
    // Worker thread is created
    /*
    The encode-worker.js file is the script that runs in the worker thread. 
    It listens for the start message from the main thread and initializes 
    the WebCodecs encoder using the VideoEncoder and VideoEncoderConfig classes.
    It then listens for VideoFrame objects from the ReadableStream that was transferred 
    from the main thread. For each frame, it encodes the frame using the encode()
    method of the VideoEncoder object and writes the resulting chunks to the 
    file using the write() method of the FileSystemWritableFileStream object
    obtained from the file handle.
    */
    encodeWorker = new Worker("./encode-worker.js");

    // Tell the worker to start encoding the frames and writing the file.
    // NOTE: transferring frameStream and reading it in the worker is more
    // efficient than reading frameStream here and transferring VideoFrames
    // individually. This allows us to entirely avoid processing frames on the
    // main (UI) thread.
    encodeWorker.postMessage(
      // The frameStream is transferred to the worker using the postMessage()
      // method with the transferable option
      {
        type: "start",
        fileHandle: handle,
        frameStream: frameStream,
        trackSettings: trackSettings,
      },
      [frameStream]
    );
    // start to upload the video chunks
    while(button.disabled) {
    await uploadVideo(frameStream);
  }
    button.innerText = "Stop";
    button.disabled = false;
  }

  async function uploadVideo(file) {
    const url = "team5@labs445-2.encs.concordia.ca";
    const formData = new FormData();
    formData.append("video", file);
    const options = {
      method: "POST",
      body: formData,
    };

    const response = await fetch(url, options);
    if (response.ok) {
      const data = await response.json();
      console.log("Upload successful:", data);
    } else {
      console.error("Upload failed:", response.statusText);
    }
  }

  /*
    When the Stop button is clicked, the stopRecording() function is called. 
    It sends the stop message to the worker, which triggers the finish() method
    of the FileSystemWritableFileStream object to finalize the video file.
  */
  function stopRecording() {
    console.assert(button.innerText == "Stop");
    button.innerText = "Record";
    encodeWorker.postMessage({ type: "stop" });

    return;
  }

  //   start or stop recording depending on what was clicked
  async function onButtonClicked() {
    switch (button.innerText) {
      case "Record":
        startRecording();
        break;
      case "Stop":
        stopRecording();
        break;
    }
  }

  //  called when webpage loads
  async function main() {
    let constraints = {
      audio: true,
      video: { width: 1280, height: 720, frameRate: 30 },
    };
    // find media that has these contrants (webcam in this case)
    stream = await window.navigator.mediaDevices.getUserMedia(constraints);
    let video = document.getElementById("video_camera");
    video.srcObject = stream;
  }

  document.body.onload = main;
</script>
